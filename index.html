<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HexLight Planner</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Custom scrollbar to match the dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo } = React;

        // --- Icons (Inline SVG to avoid external dependencies for icons) ---
        const Ruler = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></svg>
        );
        const RefreshCw = ({ size = 24, className = "" }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Info = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        );
        const MousePointer2 = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m12 12 6.8 6.8c.2.2.6.2.8 0l2.2-2.2c.2-.2.2-.6 0-.8L15 9l5.6-5.6c.4-.4.1-1.2-.5-1.2H3.5c-.6 0-1 .4-1 1v16.5c0 .6.8.9 1.2.5L9 15l3 3Z"/></svg>
        );
        const CircleDot = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="1"/></svg>
        );

        function HexCalculator() {
            // --- Constants ---
            const HEX_WIDTH = 382;
            const HEX_HEIGHT = 387;
            
            // Standard honeycomb spacing for pointy-top hexes
            const HORIZ_SPACING = HEX_WIDTH;
            const VERT_SPACING = HEX_HEIGHT * 0.75;
            const ROW_OFFSET = HEX_WIDTH / 2;

            // --- State ---
            const [gridRows, setGridRows] = useState(10);
            const [gridCols, setGridCols] = useState(10);
            
            // Store active edges as a Set of keys: "x1,y1_x2,y2"
            const [activeEdges, setActiveEdges] = useState(new Set());
            const [scale, setScale] = useState(0.15);

            // --- Helpers ---
            const toFeetInches = (mm) => {
                if (!mm) return '0\' 0"';
                const totalInches = mm / 25.4;
                const feet = Math.floor(totalInches / 12);
                const inches = Math.round(totalInches % 12);
                return `${feet}' ${inches}"`;
            };

            // Round coordinates to handle float precision issues
            const rnd = (n) => Number(n.toFixed(1));

            // Get unique key for a vertex
            const getVertexKey = (x, y) => `${rnd(x)},${rnd(y)}`;

            // Get unique key for an edge (sorts points to be direction-agnostic)
            const getEdgeKey = (p1, p2) => {
                const k1 = getVertexKey(p1.x, p1.y);
                const k2 = getVertexKey(p2.x, p2.y);
                return k1 < k2 ? `${k1}_${k2}` : `${k2}_${k1}`;
            };

            // --- Geometry Generation ---

            const getHexCenter = (r, c) => {
                const x = c * HORIZ_SPACING + ((r % 2) * ROW_OFFSET);
                const y = r * VERT_SPACING;
                return { x, y };
            };

            const getHexPoints = (cx, cy) => {
                return [
                { x: cx, y: cy - HEX_HEIGHT / 2 },                 // Top
                { x: cx + HEX_WIDTH / 2, y: cy - HEX_HEIGHT / 4 }, // Top Right
                { x: cx + HEX_WIDTH / 2, y: cy + HEX_HEIGHT / 4 }, // Bottom Right
                { x: cx, y: cy + HEX_HEIGHT / 2 },                 // Bottom
                { x: cx - HEX_WIDTH / 2, y: cy + HEX_HEIGHT / 4 }, // Bottom Left
                { x: cx - HEX_WIDTH / 2, y: cy - HEX_HEIGHT / 4 }  // Top Left
                ];
            };

            // Generate all unique edges for the current grid size
            const allEdges = useMemo(() => {
                const edgesMap = new Map();

                for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    const center = getHexCenter(r, c);
                    const points = getHexPoints(center.x, center.y);

                    for (let i = 0; i < 6; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % 6];
                    const key = getEdgeKey(p1, p2);
                    
                    if (!edgesMap.has(key)) {
                        edgesMap.set(key, { key, p1, p2 });
                    }
                    }
                }
                }
                return Array.from(edgesMap.values());
            }, [gridRows, gridCols]);

            // --- Interaction ---
            const toggleEdge = (key) => {
                const newActive = new Set(activeEdges);
                if (newActive.has(key)) {
                newActive.delete(key);
                } else {
                newActive.add(key);
                }
                setActiveEdges(newActive);
            };

            const toggleFullHex = (r, c) => {
                const center = getHexCenter(r, c);
                const points = getHexPoints(center.x, center.y);
                
                // Calculate keys for all 6 sides
                const sideKeys = [];
                for (let i = 0; i < 6; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % 6];
                sideKeys.push(getEdgeKey(p1, p2));
                }

                const newActive = new Set(activeEdges);
                
                // Check if ALL are currently selected
                const allSelected = sideKeys.every(k => newActive.has(k));

                if (allSelected) {
                // De-select all
                sideKeys.forEach(k => newActive.delete(k));
                } else {
                // Select all (fill in gaps or fresh select)
                sideKeys.forEach(k => newActive.add(k));
                }
                
                setActiveEdges(newActive);
            };

            const clearGrid = () => setActiveEdges(new Set());

            // --- Stats Calculation ---
            const stats = useMemo(() => {
                if (activeEdges.size === 0) {
                return { 
                    width: 0, height: 0, count: 0, 
                    twoWay: 0, threeWay: 0,
                    partA: 0, partB: 0, partC: 0, partD: 0
                };
                }

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                const vertexCounts = new Map();

                // Pass 1: Bounding Box & Vertex Degrees
                activeEdges.forEach(key => {
                const [start, end] = key.split('_');
                const [x1, y1] = start.split(',').map(Number);
                const [x2, y2] = end.split(',').map(Number);

                // Bounding Box
                minX = Math.min(minX, x1, x2);
                maxX = Math.max(maxX, x1, x2);
                minY = Math.min(minY, y1, y2);
                maxY = Math.max(maxY, y1, y2);

                // Vertex Counts
                vertexCounts.set(start, (vertexCounts.get(start) || 0) + 1);
                vertexCounts.set(end, (vertexCounts.get(end) || 0) + 1);
                });

                // Pass 2: Count Connectors
                let twoWay = 0;
                let threeWay = 0;
                vertexCounts.forEach((count) => {
                if (count === 2) twoWay++;
                if (count === 3) threeWay++;
                });

                // Pass 3: Count Parts
                let partA = 0; // 2 <-> 2
                let partB = 0; // 3 <-> 3
                let partC = 0; // 2 -> 3
                let partD = 0; // 3 -> 2

                activeEdges.forEach(key => {
                const [startKey, endKey] = key.split('_');
                const c1 = vertexCounts.get(startKey);
                const c2 = vertexCounts.get(endKey);

                // Determine types: 1 (open) or 2 (corner) -> Type 2. 3+ -> Type 3.
                const type1 = c1 >= 3 ? 3 : 2;
                const type2 = c2 >= 3 ? 3 : 2;

                // Determine Directionality for C vs D
                // We parse coordinates to enforce a strict geometric "Left-to-Right / Top-to-Bottom" flow
                // This ensures deterministic counting for parts
                const [x1, y1] = startKey.split(',').map(Number);
                const [x2, y2] = endKey.split(',').map(Number);

                let flowStartType, flowEndType;

                // Sort by Y, then by X to establish "Start" point
                const isNaturalOrder = (y1 < y2) || (Math.abs(y1 - y2) < 0.1 && x1 < x2);
                
                if (isNaturalOrder) {
                    flowStartType = type1;
                    flowEndType = type2;
                } else {
                    flowStartType = type2;
                    flowEndType = type1;
                }

                if (flowStartType === 2 && flowEndType === 2) partA++;
                else if (flowStartType === 3 && flowEndType === 3) partB++;
                else if (flowStartType === 2 && flowEndType === 3) partC++; // Start(2) -> End(3)
                else if (flowStartType === 3 && flowEndType === 2) partD++; // Start(3) -> End(2)
                });

                return {
                width: maxX - minX,
                height: maxY - minY,
                count: activeEdges.size, 
                twoWay,
                threeWay,
                partA,
                partB,
                partC,
                partD
                };
            }, [activeEdges]);

            // --- Rendering Prep ---
            const gridPixelWidth = gridCols * HORIZ_SPACING + ROW_OFFSET; 
            const gridPixelHeight = gridRows * VERT_SPACING + (HEX_HEIGHT / 4);
            const padding = 200; 

            return (
                <div className="flex flex-col h-screen bg-slate-900 text-slate-100 font-sans overflow-hidden">
                
                {/* Header */}
                <header className="flex-none bg-slate-800 border-b border-slate-700 p-4 shadow-lg z-10 overflow-x-auto">
                    <div className="max-w-7xl mx-auto flex flex-col xl:flex-row justify-between items-center gap-4">
                    
                    <div className="flex items-center gap-3 self-start xl:self-center shrink-0">
                        <div className="p-2 bg-green-500/20 rounded-lg text-green-400">
                        <Ruler size={24} />
                        </div>
                        <div>
                        <h1 className="font-bold text-lg leading-tight">HexLight Planner</h1>
                        <p className="text-slate-400 text-xs">Modular 3D Print System</p>
                        </div>
                    </div>

                    <div className="flex flex-wrap items-center justify-center gap-4 text-sm bg-slate-900/50 p-3 rounded-xl border border-slate-700">
                        {/* Dimensions */}
                        <div className="flex flex-col px-3 border-r border-slate-700">
                        <span className="text-slate-400 text-[10px] uppercase tracking-wider">Total Width</span>
                        <div className="flex flex-col">
                            <span className="font-mono font-bold text-green-400">{toFeetInches(stats.width)}</span>
                            <span className="text-slate-500 text-[10px]">{(stats.width).toFixed(0)} mm</span>
                        </div>
                        </div>
                        <div className="flex flex-col px-3 border-r border-slate-700">
                        <span className="text-slate-400 text-[10px] uppercase tracking-wider">Total Height</span>
                        <div className="flex flex-col">
                            <span className="font-mono font-bold text-green-400">{toFeetInches(stats.height)}</span>
                            <span className="text-slate-500 text-[10px]">{(stats.height).toFixed(0)} mm</span>
                        </div>
                        </div>
                        
                        {/* Connectors */}
                        <div className="flex gap-4 border-r border-slate-700 px-3">
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] uppercase">Edges</span>
                            <span className="font-mono font-bold text-white text-lg">{stats.count}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] uppercase">2-Way</span>
                            <span className="font-mono font-bold text-blue-300 text-lg">{stats.twoWay}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] uppercase">3-Way</span>
                            <span className="font-mono font-bold text-yellow-300 text-lg">{stats.threeWay}</span>
                        </div>
                        </div>

                        {/* Parts List */}
                        <div className="flex gap-3 px-2">
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] font-bold">Part A</span>
                            <span className="font-mono text-sm text-slate-200 bg-slate-800 px-2 rounded border border-slate-600">{stats.partA}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] font-bold">Part B</span>
                            <span className="font-mono text-sm text-slate-200 bg-slate-800 px-2 rounded border border-slate-600">{stats.partB}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] font-bold">Part C</span>
                            <span className="font-mono text-sm text-slate-200 bg-slate-800 px-2 rounded border border-slate-600">{stats.partC}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="text-slate-400 text-[10px] font-bold">Part D</span>
                            <span className="font-mono text-sm text-slate-200 bg-slate-800 px-2 rounded border border-slate-600">{stats.partD}</span>
                        </div>
                        </div>

                    </div>
                    </div>
                </header>

                {/* Main Canvas */}
                <main className="flex-1 relative overflow-auto cursor-move bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 to-slate-900">
                    
                    {/* Controls */}
                    <div className="absolute top-4 left-4 z-20 flex flex-col gap-3">
                    <div className="bg-slate-800/90 backdrop-blur border border-slate-600 p-4 rounded-xl shadow-xl w-64">
                        <h2 className="block text-sm font-medium text-slate-300 mb-2">Grid Dimensions</h2>
                        <div className="flex gap-3 mb-2">
                        <div className="flex-1">
                            <label className="text-xs text-slate-500 mb-1 block">Cols (Width)</label>
                            <input 
                            type="number" min="1" max="50"
                            value={gridCols}
                            onChange={(e) => setGridCols(Math.max(1, Number(e.target.value)))}
                            className="w-full bg-slate-900 border border-slate-600 rounded-md py-2 px-3 text-white focus:ring-2 focus:ring-green-500 outline-none"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="text-xs text-slate-500 mb-1 block">Rows (Height)</label>
                            <input 
                            type="number" min="1" max="50"
                            value={gridRows}
                            onChange={(e) => setGridRows(Math.max(1, Number(e.target.value)))}
                            className="w-full bg-slate-900 border border-slate-600 rounded-md py-2 px-3 text-white focus:ring-2 focus:ring-green-500 outline-none"
                            />
                        </div>
                        </div>
                        <button 
                        onClick={clearGrid}
                        className="mt-2 w-full flex items-center justify-center gap-2 py-2 px-4 bg-red-500/10 hover:bg-red-500/20 text-red-400 border border-red-500/50 rounded-md transition-colors"
                        >
                        <RefreshCw size={16} />
                        Reset Selection
                        </button>
                    </div>

                    <div className="bg-slate-800/90 backdrop-blur border border-slate-600 p-4 rounded-xl shadow-xl w-64 text-xs text-slate-400">
                        <div className="flex items-start gap-2">
                        <MousePointer2 size={16} className="mt-0.5 shrink-0" />
                        <p>Click <strong>lines</strong> to select edges.</p>
                        </div>
                        <div className="flex items-start gap-2 mt-2">
                        <CircleDot size={16} className="mt-0.5 shrink-0" />
                        <p>Click <strong>dots</strong> to toggle full hex.</p>
                        </div>
                        <div className="mt-2 pt-2 border-t border-slate-700 space-y-2">
                        <div className="grid grid-cols-2 gap-2">
                            <div>
                            <span className="font-bold text-slate-300">Part A</span>
                            <div className="text-[10px]">2-Way ↔ 2-Way</div>
                            </div>
                            <div>
                            <span className="font-bold text-slate-300">Part B</span>
                            <div className="text-[10px]">3-Way ↔ 3-Way</div>
                            </div>
                            <div>
                            <span className="font-bold text-slate-300">Part C</span>
                            <div className="text-[10px]">2-Way → 3-Way</div>
                            </div>
                            <div>
                            <span className="font-bold text-slate-300">Part D</span>
                            <div className="text-[10px]">3-Way → 2-Way</div>
                            </div>
                        </div>
                        </div>
                    </div>
                    </div>

                    {/* Zoom */}
                    <div className="absolute bottom-4 right-4 z-20 bg-slate-800/90 backdrop-blur border border-slate-600 rounded-lg p-2 flex flex-col gap-2">
                    <button onClick={() => setScale(s => Math.min(s + 0.05, 0.5))} className="p-2 hover:bg-slate-700 rounded text-slate-300">+</button>
                    <button onClick={() => setScale(s => Math.max(s - 0.05, 0.02))} className="p-2 hover:bg-slate-700 rounded text-slate-300">-</button>
                    </div>

                    {/* SVG Area */}
                    <div className="min-w-full min-h-full flex items-center justify-center p-20">
                        <svg 
                        width={(gridPixelWidth + padding * 2) * scale} 
                        height={(gridPixelHeight + padding * 2) * scale}
                        viewBox={`${-padding} ${-padding} ${gridPixelWidth + padding*2} ${gridPixelHeight + padding*2}`}
                        className="transition-all duration-300"
                        >
                        <defs>
                            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
                            </filter>
                        </defs>

                        {/* Draw Edges */}
                        {allEdges.map(({ key, p1, p2 }) => {
                            const isActive = activeEdges.has(key);
                            return (
                            <g key={key} className="group">
                                
                                {/* Glow Layer */}
                                {isActive && (
                                <line 
                                    x1={p1.x} y1={p1.y} 
                                    x2={p2.x} y2={p2.y} 
                                    stroke="#4ade80" 
                                    strokeWidth="20" 
                                    strokeLinecap="round"
                                    opacity="0.6"
                                    filter="url(#glow)"
                                    className="pointer-events-none"
                                />
                                )}

                                {/* Core Line */}
                                <line 
                                x1={p1.x} y1={p1.y} 
                                x2={p2.x} y2={p2.y} 
                                stroke={isActive ? "#4ade80" : "#334155"} 
                                strokeWidth={isActive ? "8" : "2"}
                                strokeLinecap="round"
                                className="transition-colors duration-150 pointer-events-none"
                                />
                                
                                {/* Hover Effect */}
                                <line 
                                x1={p1.x} y1={p1.y} 
                                x2={p2.x} y2={p2.y} 
                                stroke="#94a3b8" 
                                strokeWidth="6" 
                                strokeLinecap="round"
                                className={`opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none ${isActive ? 'hidden' : ''}`}
                                />

                                {/* Hit Target */}
                                <line 
                                x1={p1.x} y1={p1.y} 
                                x2={p2.x} y2={p2.y} 
                                stroke="rgba(0,0,0,0)" 
                                strokeWidth="80" 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    toggleEdge(key);
                                }}
                                className="cursor-pointer"
                                />
                            </g>
                            );
                        })}

                        {/* Draw Center Dots */}
                        {Array.from({ length: gridRows }).map((_, r) => (
                            Array.from({ length: gridCols }).map((_, c) => {
                            const { x, y } = getHexCenter(r, c);
                            return (
                                <circle 
                                    key={`dot-${r}-${c}`}
                                    cx={x} cy={y}
                                    r={20}
                                    fill="#64748b"
                                    className="cursor-pointer hover:fill-white transition-colors"
                                    onClick={(e) => {
                                    e.stopPropagation();
                                    toggleFullHex(r, c);
                                    }}
                                />
                            )
                            })
                        ))}

                        </svg>
                    </div>
                </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HexCalculator />);
    </script>
</body>
</html>
